.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "HMALLOC" "3" "Apr, 2024" "HMSDK Programmer\[cq]s Manuals" ""
.hy
.SH NAME
.PP
hmalloc, hfree, hcalloc, hrealloc - allocate and free heterogeneous
dynamic memory
.SH SYNOPSIS
.PP
\f[B]#include <hmalloc.h>\f[R]
.PP
\f[B]void *hmalloc(size_t \f[BI]size\f[B]);\f[R]
.PD 0
.P
.PD
\f[B]void hfree(void \f[BI]*ptr\f[B]);\f[R]
.PD 0
.P
.PD
\f[B]void *hcalloc(size_t \f[BI]nmemb\f[B], size_t
\f[BI]size\f[B]);\f[R]
.PD 0
.P
.PD
\f[B]void *hrealloc(void \f[BI]*ptr\f[B], size_t \f[BI]size\f[B]);\f[R]
.SH DESCRIPTION
.PP
The \f[B]hmalloc\f[R]() function allocates dynamic memory managed in
\f[B]hmalloc pool\f[R] that can be optionally controlled by
\f[B]hmctl\f[R](8) tool and this can make those dynamic memory be
allocated on a specific NUMA node.
Except for this, hmalloc works exactly same as \f[B]malloc\f[R](3).
.PP
Likewise, \f[B]hcalloc\f[R]() and \f[B]hrealloc\f[R]() work exactly same
as \f[B]calloc\f[R](3) and \f[B]realloc\f[R](3), but the allocated
memory can be optionally managed by \f[B]hmctl\f[R](8) tool just like
\f[B]hmalloc\f[R]().
.PP
All those dynamic memory allocated by \f[B]hmalloc\f[R](),
\f[B]hcalloc\f[R](), and \f[B]hrealloc\f[R]() should be freed by
\f[B]hfree\f[R]().
.SH GLOSSARY
.SS HMALLOC APIS
.PP
The \f[B]hmalloc APIs\f[R] are heterogeneous memory allocation APIs
provided by \f[B]libhmalloc.so\f[R] such as \f[B]hmalloc\f[R](3),
\f[B]hcalloc\f[R](3), \f[B]hposix_memalign\f[R](3), \f[B]hmmap\f[R](3),
etc.
All the APIs defined in \f[B]hmalloc.h\f[R] are \f[B]hmalloc APIs\f[R].
.SS HMALLOC POOL
.PP
The \f[B]hmalloc pool\f[R] is specially managed memory areas that can be
optionally controlled by \f[B]hmctl\f[R](8) tool.
If target programs allocate memory using \f[B]hmalloc APIs\f[R], then
this area is mapped as \f[B]hmalloc pool\f[R].
This \f[B]hmalloc pool\f[R] has no effect if the target program runs
without \f[B]hmctl\f[R](8), but if it runs with \f[B]hmctl\f[R](8)
attached, then the memory policy of this area can be changed based on
the usage of \f[B]hmctl\f[R](8).
.SS HMCTL
.PP
The \f[B]hmctl\f[R](8) is a tool that controls heterogeneous memory
allocation policy.
That means it can change the memory policy of \f[B]hmalloc pool\f[R]
allocated by \f[B]hmalloc APIs\f[R] internally using \f[B]mmap\f[R](2)
and \f[B]mbind\f[R](2).
If \f[B]hmctl\f[R](8) is attached and
\f[B]-m\f[R]/\f[B]\[en]membind\f[R] or
\f[B]-p\f[R]/\f[B]\[en]preferred\f[R] option is given with a valid NUMA
node ID, then the \f[B]hmalloc pool\f[R] memory is allocated from the
target node with the given memory policy based on the usage of
\f[B]hmctl\f[R](8).
.SH RETURN VALUE
.PP
The return values of \f[B]hmalloc\f[R], \f[B]hcalloc\f[R], and
\f[B]hrealloc\f[R] are same as \f[B]malloc\f[R](3), \f[B]calloc\f[R](3),
and \f[B]hrealloc\f[R](3).
.SH ERRORS
.PP
Likewise, \f[B]hmalloc\f[R](), \f[B]hcalloc\f[R](), and
\f[B]hrealloc\f[R]() can fail with the following error:
.PP
\f[B]ENOMEM\f[R] Out of memory.
Possibly, the application hit the \f[B]RLIMIT_AS\f[R] or
\f[B]RLIMIT_DATA\f[R] limit described in \f[B]getrlimit\f[R](2).
.SH SEE ALSO
.PP
\f[B]hmctl\f[R](8), \f[B]malloc\f[R](3), \f[B]free\f[R](3),
\f[B]calloc\f[R](3), \f[B]realloc\f[R](3)
.SH AUTHORS
Honggyu Kim <honggyu.kim@sk.com>, Yunjeong Mun <yunjeong.mun@sk.com>.
