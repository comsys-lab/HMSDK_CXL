.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "HMMAP" "3" "Apr, 2024" "HMSDK Programmer\[cq]s Manuals" ""
.hy
.SH NAME
.PP
hmmap, hmunmap - map or unmap files or devices into heterogeneous memory
.SH SYNOPSIS
.PP
\f[B]#include <hmalloc.h>\f[R]
.PP
\f[B]void *hmmap(void *\f[BI]addr\f[B], size_t \f[BI]length\f[B], int
\f[BI]prot\f[B], int \f[BI]flags\f[B], int \f[BI]fd\f[B], off_t
\f[BI]offset\f[B]);\f[R]
.PD 0
.P
.PD
\f[B]int hmunmap(void *\f[BI]addr\f[B], size_t \f[BI]length\f[B]);\f[R]
.SH DESCRIPTION
.PP
\f[B]hmmap\f[R]() creates a new mapping in the virtual address space of
the calling process same as \f[B]mmap\f[R](2) so the meaning of each
argument can simply be refer to the manual of \f[B]mmap\f[R](2).
.PP
However, there are some differences between \f[B]hmmap\f[R] and
\f[B]mmap(2)\f[R].
The \f[B]hmmap\f[R] allocates memory in \f[B]hmalloc pool\f[R] that can
be optionally controlled by \f[B]hmctl\f[R](8) tool.
.SH GLOSSARY
.SS HMALLOC APIS
.PP
The \f[B]hmalloc APIs\f[R] are heterogeneous memory allocation APIs
provided by \f[B]libhmalloc.so\f[R] such as \f[B]hmalloc\f[R](3),
\f[B]hcalloc\f[R](3), \f[B]hposix_memalign\f[R](3), \f[B]hmmap\f[R](3),
etc.
All the APIs defined in \f[B]hmalloc.h\f[R] are \f[B]hmalloc APIs\f[R].
.SS HMALLOC POOL
.PP
The \f[B]hmalloc pool\f[R] is specially managed memory areas that can be
optionally controlled by \f[B]hmctl\f[R](8) tool.
If target programs allocate memory using \f[B]hmalloc APIs\f[R], then
this area is mapped as \f[B]hmalloc pool\f[R].
This \f[B]hmalloc pool\f[R] has no effect if the target program runs
without \f[B]hmctl\f[R](8), but if it runs with \f[B]hmctl\f[R](8)
attached, then the memory policy of this area can be changed based on
the usage of \f[B]hmctl\f[R](8).
.SS HMCTL
.PP
The \f[B]hmctl\f[R](8) is a tool that controls heterogeneous memory
allocation policy.
That means it can change the memory policy of \f[B]hmalloc pool\f[R]
allocated by \f[B]hmalloc APIs\f[R] internally using \f[B]mmap\f[R](2)
and \f[B]mbind\f[R](2).
If \f[B]hmctl\f[R](8) is attached and
\f[B]-m\f[R]/\f[B]\[en]membind\f[R] or
\f[B]-p\f[R]/\f[B]\[en]preferred\f[R] option is given with a valid NUMA
node ID, then the \f[B]hmalloc pool\f[R] memory is allocated from the
target node with the given memory policy based on the usage of
\f[B]hmctl\f[R](8).
.SH RETURN VALUE
.PP
On success, \f[B]hmmap\f[R]() returns a pointer to the mapped area in
\f[B]hmalloc pool\f[R].
.PP
On error of \f[B]hmmap\f[R]() due to the internal \f[B]mmap\f[R](2)
fails, the value \f[B]MAP_FAILED\f[R] (that is, \f[I](void *) -1\f[R])
is returned, and \f[I]errno\f[R] is set by \f[B]mmap\f[R](2) to indicate
the cause of the error.
If \f[B]mmap\f[R](2) is successful but \f[B]mbind\f[R](2) fails, then it
unmaps the area again and returns \f[B]NULL\f[R] with \f[I]errno\f[R]
set by \f[B]mbind\f[R](2).
.PP
On success, \f[B]hmunmap\f[R]() returns 0.
On failure, it returns -1, and \f[I]errno\f[R] is set to indicate the
cause of the error (probably to \f[B]EINVAL\f[R]).
.SH ERRORS
.PP
See \f[B]mmap\f[R](2), \f[B]mbind\f[R](2) and \f[B]munmap\f[R](2)
.SH SEE ALSO
.PP
\f[B]hmctl\f[R](8), \f[B]mmap\f[R](2), \f[B]mbind\f[R](2),
\f[B]munmap\f[R](2)
.SH AUTHORS
Honggyu Kim <honggyu.kim@sk.com>, Yunjeong Mun <yunjeong.mun@sk.com>.
